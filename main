import imaplib
import email
from email.header import decode_header
import datetime
from email.message import Message
from time import time


#специальный словарь у которого под один ключь много параметров
class Dictlist(dict):
    def __setitem__(self, key, value):
        try:
            self[key]
        except KeyError:
            super(Dictlist, self).__setitem__(key, [])
        self[key].append(value)


address = 'dan020304dan93@gmail.com'
password = 'ufggzyqlhvrnrbic'

date=(datetime.datetime.now()).strftime("%d %b %Y")


if date[0] == '0':
    datee = date[1]+date[2]+date[3]+date[4]+date[5]+date[6]+date[7]+date[8]+date[9]+date[10]

print(datee)

# Initiate a connection with the host (in this case, Gmail)
server = "imap.gmail.com"
imap = imaplib.IMAP4_SSL(server)

# login into the gmail account
imap.login(address, password)


# Using SELECT to chose the e-mails.
res, messages = imap.select('INBOX')

# Caluclating the total number of sent Emails
messages = int(messages[0])

# Number of recent e-mails to be fetched
n = 20

counter = []
pidoras228 = Dictlist()
slave228 = Dictlist()

# Iterating over the sent emails
for i in range(messages, messages - n, -1):
    res, msg = imap.fetch(str(i), "(RFC822)")  # Using the RFC822 protocol
    for response in msg:
        if isinstance(response, tuple):
            msg = email.message_from_bytes(response[1])

            # Retrieving the senders email
            From = msg["From"]

            # Retrieving the subject of the email
            subject = msg["Subject"]

            # Retrieving the data of the email
            datepidor = msg["Date"]


#по уебански подгоняем дату по параметрам (нужно исправить)
            datepidorr = datepidor[5]+datepidor[6]+datepidor[7]+datepidor[8]+datepidor[9]+datepidor[10]+ \
            datepidor[11]+ datepidor[12]+ datepidor[13]+ datepidor[14]

            if datepidorr[0] == '0':
                datepidorr = datepidor[6]+datepidor[7]+datepidor[8]+datepidor[9]+datepidor[10]+ \
            datepidor[11]+ datepidor[12]+ datepidor[13]+ datepidor[14]+ datepidor[15]

# проверка на время, немного уебанская может похже придумать как фильтровать сразу письма по дате
#а так она просто проеряет совпадает ли дата отправленного письма с сегодняшней датой
#переобразовуя дату с письма под формат даты питона
            if datepidorr == datee:

#создаем наш особый словарь где ключь это отправитель а параметры - сабджект письма
                counter.append(From)
                tu = From
                yo =  decode_header(msg["Subject"])[0][0]
                pidoras228[tu]= yo


                #print("From : " , From)


#создаем наш особый словарь где ключь это отправитель а параметры - бади письма
                if msg.is_multipart():
                    # iterate over email parts
                    for part in msg.walk():
                        # extract content type of email
                        content_type = part.get_content_type()
                        content_disposition = str(part.get("Content-Disposition"))
                        try:
                            # get the email body
                            body = part.get_payload(decode=True).decode()
                        except:
                            pass
                        if content_type == "text/plain" and "attachment" not in content_disposition:
                            # print text/plain emails and skip attachments
                            slave228[From]=body
                print(slave228)



#эта переменная создает масив с ключами соотвецтвуюших нашему параметру быть >= 10
pedro = list((x) for x in set(counter) if counter.count(x) >= 2)

#эти два цикла проверяют нет ли у нас в контейнере элементов не соотвецтвуюших нашему параметру быть >= 10
#Если есть, он его удаляет
x=0
while x< len(pidoras228.keys()):
    if list(pidoras228.keys())[x] in pedro:
        print()
    else:
        pidoras228.pop(list(pidoras228.keys())[x])
        x-=1
    x+=1

x=0
while x< len(slave228.keys()):
    if list(slave228.keys())[x] in pedro:
        print()
    else:
        slave228.pop(list(slave228.keys())[x])
        x-=1
    x+=1

print(pidoras228)

#print(pidoras228)


#print(" ".join(pidoras228[pedro[0]]))

print(pedro)

mainstring =""

x=0
n=0
#эти два цикла считают количество букв и цивр сначала в сабджекте а потом в бади письма
d = {'Буквы': 0, 'Цифры': 0}
while x < len(pidoras228):
    while n< len(pidoras228[pedro[x]]):
        for i in pidoras228[pedro[x]][n]:
            if i.isalpha():
              d['Буквы'] += 1
            elif i.isdigit():
              d['Цифры'] += 1
        n+=1
    x+=1

x=0
n=0
while x < len(slave228):
    while n< len(slave228[pedro[x]]):
        for i in slave228[pedro[x]][n]:
            if i.isalpha():
              d['Буквы'] += 1
            elif i.isdigit():
              d['Цифры'] += 1
        n+=1
    x+=1

print(d['Цифры'], d['Буквы'])

x=0
while x < len(pidoras228.keys()):
    mainstring = "Received mails on themes:  "+ " ".join(pidoras228[pedro[x]])+"With messages: "+" ".join(slave228[pedro[x]])+\
            "It contains "+ str(d['Буквы'])+" letters and "+str(d['Цифры'])+" numbers."
    x+=1

print(mainstring)

new_message = Message()
new_message["From"] = "hello@itsme.com"
new_message["Subject"] = "My new mail."
new_message.set_payload("This is my message.")

imap.append('INBOX', '', imaplib.Time2Internaldate(time()), mainstring.encode('utf-8'))
